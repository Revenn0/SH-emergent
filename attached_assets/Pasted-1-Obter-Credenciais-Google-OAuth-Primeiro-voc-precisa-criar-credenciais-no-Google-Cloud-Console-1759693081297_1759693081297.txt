1ï¸âƒ£ Obter Credenciais Google OAuth
Primeiro, vocÃª precisa criar credenciais no Google Cloud Console:

Acesse: https://console.cloud.google.com/
Crie um projeto ou selecione existente
VÃ¡ em APIs & Services â†’ Credentials
Clique em Create Credentials â†’ OAuth 2.0 Client ID
Configure:
Application type: Web application
Authorized JavaScript origins:
https://seu-projeto.replit.app (seu domÃ­nio Replit)
Authorized redirect URIs:
https://seu-projeto.replit.app/api/auth/google/callback
Salve o Client ID e Client Secret
2ï¸âƒ£ Atualizar o Backend
VocÃª jÃ¡ tem o playbook de Google OAuth no sistema. Precisa substituir o cÃ³digo de Emergent Auth pelo cÃ³digo de Google OAuth direto.

Instalar biblioteca necessÃ¡ria:

pip install authlib
Modificar /app/backend/server.py:

Substitua a seÃ§Ã£o de Emergent Auth por este cÃ³digo:

from authlib.integrations.starlette_client import OAuth
from starlette.middleware.sessions import SessionMiddleware

# Adicione logo apÃ³s criar o app
app.add_middleware(SessionMiddleware, secret_key=os.environ.get('SESSION_SECRET', 'your-secret-key-here'))

# Configure OAuth
oauth = OAuth()
oauth.register(
    name='google',
    client_id=os.environ.get('GOOGLE_CLIENT_ID'),
    client_secret=os.environ.get('GOOGLE_CLIENT_SECRET'),
    server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
    client_kwargs={'scope': 'openid email profile'}
)

# Substitua os endpoints de auth
@api_router.get("/auth/login")
async def auth_login(request: Request):
    """Inicia login Google OAuth"""
    redirect_uri = request.url_for('auth_callback')
    return await oauth.google.authorize_redirect(request, redirect_uri)


@api_router.get("/auth/google/callback")
async def auth_callback(request: Request, response: Response):
    """Processa callback do Google"""
    try:
        token = await oauth.google.authorize_access_token(request)
        user_info = token.get('userinfo')
        
        # Verifica se usuÃ¡rio existe
        existing_user = await db.users.find_one({"email": user_info["email"]})
        
        if not existing_user:
            # Cria novo usuÃ¡rio
            user = User(
                email=user_info["email"],
                name=user_info.get("name", ""),
                picture=user_info.get("picture", "")
            )
            await db.users.insert_one(user.dict())
            user_id = user.id
        else:
            user_id = existing_user["id"]
        
        # Cria sessÃ£o
        session_token = str(uuid.uuid4())
        expires_at = datetime.now(timezone.utc) + timedelta(days=7)
        
        session = UserSession(
            user_id=user_id,
            session_token=session_token,
            expires_at=expires_at
        )
        
        await db.user_sessions.insert_one(session.dict())
        
        # Define cookie
        response = RedirectResponse(url="/dashboard")
        response.set_cookie(
            key="session_token",
            value=session_token,
            httponly=True,
            secure=True,
            samesite="lax",
            max_age=7 * 24 * 60 * 60,
            path="/"
        )
        
        return response
        
    except Exception as e:
        logger.error(f"Auth callback error: {str(e)}")
        return RedirectResponse(url="/?error=auth_failed")


# Mantenha os endpoints /auth/me e /auth/logout como estÃ£o
3ï¸âƒ£ Atualizar o Frontend
Modificar /app/frontend/src/App.js:

Na funÃ§Ã£o handleLogin, mude de:

// ANTES (Emergent Auth)
const handleLogin = async () => {
  setLoading(true);
  try {
    const response = await api.get("/auth/login");
    window.location.href = response.data.auth_url;
  } catch (error) {
    console.error("Login error:", error);
    alert("Failed to initiate login");
    setLoading(false);
  }
};
Para:

// DEPOIS (Google OAuth Direto)
const handleLogin = () => {
  window.location.href = `${API}/auth/login`;
};
Remover o cÃ³digo de processamento de session_id:

Delete esta parte do useEffect:

// REMOVER ISTO:
const hash = window.location.hash;
if (hash.includes("session_id=")) {
  const sessionId = hash.split("session_id=")[1].split("&")[0];
  processSessionId(sessionId);
} else {
  checkAuth();
}

// E a funÃ§Ã£o processSessionId tambÃ©m
Substituir por:

useEffect(() => {
  checkAuth();
}, []);
4ï¸âƒ£ Configurar VariÃ¡veis de Ambiente no Replit
No Replit, vÃ¡ em Secrets e adicione:

GOOGLE_CLIENT_ID=seu_client_id_aqui
GOOGLE_CLIENT_SECRET=seu_client_secret_aqui
SESSION_SECRET=uma_chave_secreta_aleatoria
MONGO_URL=sua_mongodb_connection_string
DB_NAME=test_database
5ï¸âƒ£ Atualizar requirements.txt
Adicione:

authlib
itsdangerous
ğŸ“‹ Resumo das MudanÃ§as
Componente	Emergent Auth	Google OAuth Direto
AutenticaÃ§Ã£o	Gerenciada pela Emergent	VocÃª gerencia
Redirect	Para domÃ­nio Emergent	Para seu domÃ­nio Replit
Credenciais	NÃ£o precisa	Precisa Client ID/Secret
CÃ³digo Backend	Endpoint simples	OAuth flow completo
CÃ³digo Frontend	Processa session_id	Redirect direto
Depois dessas mudanÃ§as, o fluxo serÃ¡:

UsuÃ¡rio clica "Entrar com Google"
Redireciona para Google OAuth
Google redireciona de volta para seu domÃ­nio Replit
Sistema cria sessÃ£o e redireciona para dashboard
Precisa de ajuda para implementar essas mudanÃ§as? ğŸš€